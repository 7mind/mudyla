Our goal is to implement a shell script orchestrator.

The tool is named "mudyla" (Multimodal Dynamic Launcher).

It should be implemented in Python and should be distributed as a reusable Nix flake.

The tool should take one or more (with a glob) markdown files. An example file is `example.md` Default value is .mdl/defs/**.md, overridable with `--defs`

Then the tool should find all the sections in the documents which has a header (of any level)
in the following format "action: minus-separated-action-name". If there are two sections with duplicated names, we should throw an error. If we found an action definition, we don't try to extract nested action definitions.

In each section we ignore any text. Each section should contain exactly one code section with type "bash". That section represents action body and is a bash script which needs preprocessing before it can be executed. The code section might be nested into a markdown subsection.

In each bash section we should extract all the invalid bash expansions in the following form: ${dot.separated.expression}.

There might be several types of expressions:

- ${sys.variable-name} - such values should be substitued by one of the values our tool will provide. For starters we will have just sys.project-root variable which should point to the actual project root (we should find the closes parent folder with .git directory to find that variable, if we can't, that's an error).

- ${action.action-name.variable-name} - this declares dependency on `action-name` and this expansion should be substituted by `variable-name` returned by the action.

- ${env.VARIABLE_NAME} - this declares dependency on environment variable VARIABLE_NAME and should be subsituted with it. Important distinction: the presence of such variables is validated before we run our scripts. Variables can be documented in a subsection named `vars` (see example file).

- ${args.output-directory} - this expansion should be substituted by run arguments (see below)
- ${flags.use-fastopt} - this expansion should be substituted by 1 if run flag is present (see below).

Arguments and flags can be described in special sections named "arguments" and flags (see the example file).

Every action explicitly declares what it can return by calling a pseudo-function (which should be provided by our runner in runtime).
The format is: `ret out-name:type=value`, e.g.  `ret compiler-binary:file=${sys.project-root}/baboon-compiler/.jvm/target/graalvm-native-image/baboon`. We should support the following types:

- int
- string
- directory
- file

If a function returns a file or a directory, we should check their presence before returning, not present means failure.


When the user calls our tool, they define a set of action names which they want to be run (root actions or goals):

Commandline example:

```
mdl --defs "build/**.md" --flag --parameter=value --axis build-mode=production :goal1 :goal2
```

This commandline means that the user wants to run action named "goal1" and "goal2". We should only run actions which are needed for goal1 and goal2. Flags should be considered as int values set to 1 if present. By default

We do it the following way:

Once we processed our documents into a parsed internal representation of our actions, we should build a DAG out of it. We should use ${action.action-name....} expansions to define dependencies. We trace our graph from the root goals to figure out what we need to be left in the graph and what can be excluded.

Then we should validate the graph:
- that every environment variable declared by ${env.} expansion is present
- that every mandatory argument was defined
- the graph is actually acyclic
- all outputs needed by some actions are actually returned from the dependencies

Then we can execute the actions of our graph (see below).

The execution strategy:

1) Each action run as an individual process with required environment variables pre-set
2) We run every action under Nix using `nix develop --keep ... --command bash script`. We assume that there will always be `flake.nix` in the directory where we run.
3) Script is the rendered version of action
4) the `ret` function should be included into the rendered version
5) the function should synthetise a json file with action output
6) When we run an action, we should render it, expanding the expansions with the values from the jsons generated by the dependencies.
7) We should capture and save in the per-run directory stderr/stdout of every action. If an action fails, we print the outputs.

The outputs of our tool should be printed to the console as a json file in the following form:

```json
{
    "action-name": {action-return-value: ...},
    "action-name2": {action2-return-value: ...},
}
```

Also user may specify output file as `mdl --out <path-to-out-json>`.

The return values of every run should be saved into json files in per-run temporary directory (default value `.mdl/runs/<run-id>). The temporary directory must be cleaned after successful run and must be kept after failed run.

The tool should be able to print all available actions, the arguments and flags they need/might have, the environment variables which are required, available axis and which actions are bound to which axis.
Before execution the tool should print the plan (the graph which we are about to execute).

Important feature: an action may have several versions defined in sections with headers like ## definition when `build-mode: release`
When we need to choose which version we need to use, we should consdier which axis flags are available and were set. If user didn't specify some flags, we should fail with an explanation.

Our tool should have a good test project.
